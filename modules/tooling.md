# Tooling

![Moderate](https://img.shields.io/badge/Difficulty-%E2%97%8F%20Easy-brightgreen?style=flat-square)
<a href="https://github.com/engineerkit/engineerkit/discussions">![Ask Questions](https://img.shields.io/badge/Ask%20Questions%20-blue.svg?style=flat-square&logo=discourse&logoWidth=15&labelColor=555&color=4d51cc)</a>

### With this module, you’ll learn how to streamline your workflow and assemble a dev environment using standard tools and practices, allowing you to focus on crafting quality code.

<img src="https://media.istockphoto.com/photos/hand-tools-picture-id487125438?k=20&m=487125438&s=612x612&w=0&h=nn48Th50FUrs6Q0o9gUWHd3WyPWStTtDCynnjsUUeSA=" width="1000" />

## Topics

<details open>
   <summary><b>Fundamentals of Tooling</b></summary><br/>

   With this topic, 

   #### Learning Outcomes
   * List common tools that might be utilized
   * 
   * 

   #### Resources
   * 
   * 
   * 
   * 

   ----
</details>
<details open>
   <summary><b>Source Control</b></summary><br/>

   With this topic, 

   #### Learning Outcomes
   * Describe what source control is and its purpose
   * List common source control providers
   * List common Git commands and their purpose
   * Describe Semantic Versioning and its purpose
   * Compare using source control and not using source control to manage a project

   #### Resources
   * 
   *
   *

   ----
</details>
<details open>
   <summary><b>Editors</b></summary><br/>

   With this topic, 

   #### Learning Outcomes
   * Describe what an IDE is
   * List common IDEs

   #### Resources
   * 

   ----
</details>
<details open>
   <summary><b>Using the Terminal</b></summary><br/>

   With this topic, 

   #### Learning Outcomes
   * Describe what a command line interface is and how you might use it
   * 

   #### Resources
   * 
   * 
   
   ----
</details>

<details open>
   <summary><b>Productivity Tools</b></summary><br/>

   With this topic, 

   #### Learning Outcomes
   * List common productivity tools and their use case
   * 

   #### Resources
   * 
   * 
   
   ----
</details>

<details open>
   <summary><b>Prototyping Tools</b></summary><br/>

   With this topic, 

   #### Learning Outcomes
   * List common prototyping tools
   * 

   #### Resources
   * 
   * 
   
   ----
</details>

### Resources

* 
* 
* 





# Tooling

## Overview

> With this topic, you’ll learn how to streamline your workflow and assemble a dev environment using standard tools and practices, allowing you to focus on crafting quality code.

<p align="left">
   <a href="https://youtu.be/Yd2SUHgmnoY"><img src="https://j.gifs.com/0Yk6DV.gif"></a>
</p>

----

## Apprentice

### Learning Goals

* **Editors**
   * Set up an editor that they are comfortable with using in their day-to-day work.
   * Leverage their experience with a few different editors in order to facilitate pair programming.
   * Use a few basic Vim commands when working on remote servers.
* **Git**
   * Explain the purpose of version control.
   * Manage their personal workflow with basic git commands (e.g. `git add`, `git commit`, `git push`).
   * Synchronize their work with the work of their teammates using a system like GitHub.
* **Shells**
   * Navigate the filesystem using shell commands (e.g. `cd`, `ls`, `pwd`).
   * View and manipulate files using shell commands (e.g. `mv`, `cp`, `cat`, `rm`, `touch`, `mkdir`).
   * Manage file and system settings using shell commands (e.g. `sudo`, `chmod`).
   * Write a simple shell script that incorporates other known commands.
* **One Heavyweight IDE (e.g. Visual Studio, JetBrains)**
   * Set up and use an IDE like JetBrains or Visual Studio for a software project.
   * Leverage their experience with an IDE in order to facilitate pair programming.
* **Web Developer Tools**
   * View the console in the browser.
   * Identify network requests in the browser.
   * View the HTML of a web page in the browser.
* **Owning and Customizing your Editor**
   * Customize their editor with fonts, colors, and plugins that compliment their development style.
* **Static Analysis**
   * Explain the purpose of static analysis in a project.
   * Set up a static analysis system on a project.
* **Linters**
   * Explain the purpose of a linter in a project.
   * Set up a linter on a project.


### Learning Style

There are many different ways that you could learn about this topic. Here are some examples:

* **Kinesthetic**: Practice keyboard shortcuts in order to develop muscle memory.
* **Existential**: Develop an opinion over whether vim or emacs is better and argue about it with your colleagues during lunch.
* **Interpersonal**: Pair program with a remote partner using Floobits or VSCode Live.
* **Visual-Spatial**: Customize your editor and terminal to fit your specific programming style


### Skill Indicators

Part of the calibration process is to assess your current skill level in this topic. Here are some example skill indicators that might help you as you fill out the Calibration Matrix:

<details>
<summary><b>I have never heard of this topic</b></summary>

* I do not know of any text editors that are useful for software development.
* I have only written and run code in an online editor (e.g. Codewars, Exercism).
* I do not know what version control is.
* I have never used version control before.
* I have never run commands in a shell before.
* I do not know what an IDE is.
* I do not know how to open up the developer tools in the browser.
* I have not made any decisions as to which editor I want to use consistently.
* I do not know what static analysis is.
* I have never heard of linting in the context of software development.
</details>

<details>
<summary><b>I have heard of this topic, but I do not feel comfortable utilizing it on a project</b></summary>

* I have used the text editor that comes installed on my laptop, but I have never used an editor geared towards developers (e.g. TextEdit).
* I have heard of version control systems like Git before, but I have never really used them in practice.
* I choose to use a GUI based system for git because I do not know the command line arguments that are required.
* I can navigate the filesystem in a shell, but I cannot do anything past that (e.g. `cd`, `ls`, `pwd`).
* I know what an IDE is, but I have never used one in development.
* I can open up the developer tools in the browser, but I am not sure how to use them effectively.
* I have an editor that I use consistently, but I do not know which customizations are available for that particular editor.
* I have heard of static analysis, but I have never used it in a codebase before.
* I have heard of linting, but I have never used it in a codebase before.
</details>

<details>
<summary><b>I can give a definition or example of this topic, and I feel comfortable utilizing this topic on a project with some guidance</b></summary>

* I have tried one or two text editors, but I do not know which one I prefer.
* I have used a text editor or IDE in my work, but I did not utilize its full capacity (e.g. short keys, custom user and workplace settings).
* I have used git and GitHub before, but I really only know some basic commands like `git add`, `git commit`, and `git push`.
* I can navigate through a filesystem and manipulate files using shell commands (e.g. `mv`, `cp`, `cat`, `rm`, `touch`, `mkdir`).
* I can write code and run the test suite in an IDE, but I do not know how to use any of its more advanced features (e.g. build the project, run static analysis or linting, take advantage of refactoring tools).
* I can open up the developer tools in the browser and access the console and HTML of the current webpage.
* I have an editor that I use consistently, but I am still experimenting with packages that customize my workflow.
* I can set up ESLint in a Javascript project.
* I can set up Rubocop in a Ruby project.
* I can set up code review tools and test coverage measurement tools for my project.
</details>

<details>
<summary><b>I can give a definition or example of this topic, and I feel comfortable utilizing this topic on a project with little to no guidance</b></summary>

* I have picked a favorite editor or IDE after trying a few different options.
* I have picked a favorite editor and I'm comfortable using its short keys, custom user and workplace settings, code navigation and other features. I can customize my favorite editor settings for my needs.
* I can open a pull request, make necessary edits to the code, and then merge it into a master branch.
* I can commit and push changes to an online code management system like GitHub or BitBucket.
* I know what a merge conflict is and how to resolve it.
* I can use more advanced git commands when needed (like amending commits, rebasing branches, squashing commits, stashing changes, etc).
* My commit messages are short but descriptive, well-formatted, and they follow the style of the repository.
* I can successfully pair program with a Software Engineer who uses a different editor setup than I do.
* I can navigate through a filesystem, manipulate files using shell commands, and use more advanced commands like `sudo` and `chmod`.
* I can navigate through a filesystem, manipulate files using shell commands, and use flags to make my commands more robust like `ls -a`, `ls *`,  `cp -R` etc.
* I can write a simple shell script.
* I choose to use a GUI based system for git out of a personal preference, but I could perform git commands through the command line if needed.
* I can run code in Developer Tools Console and use Snippets if needed.
* I can use Developer Tools to access information about network usage like requests and responses the page is sending and getting.
* I can customize my Developer Tools if needed, for example adding React Developer Tools.
* I can utilize an IDE to build, test, and run a project rather than separate terminal commands.
* I have customized my editor of choice with fonts, colors, and plugins that I find useful.
* I can attach a git hook to a project that automatically runs a static analysis before commits.
* I can attach a git hook to a project that automatically runs a linter before commits.
* I can write custom linter rules that fit my project codebase better.
</details>

### Resources

* [Atom](https://atom.io/)
* [BitBucket](https://bitbucket.org)
* [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools/)
* [Editors (Vim)](https://missing.csail.mit.edu/2020/editors/)
* [ESLint](https://eslint.org/)
* [GitHooks](https://githooks.com/)
* [GitHub](https://github.com/)
* [GNU Emacs](https://www.gnu.org/software/emacs/)
* [JetBrains](https://www.jetbrains.com/)
* [MDN web docs - Browser Developer Tools](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_are_browser_developer_tools)
* [Pro Git](https://git-scm.com/book/en/v2)
* [Rubocop](https://github.com/rubocop-hq/rubocop)
* [Static Code Analysis](https://owasp.org/www-community/controls/Static_Code_Analysis)
* [Sublime Text](https://www.sublimetext.com/)
* [Vim Adventures](https://vim-adventures.com/)
* [Visual Studio](https://visualstudio.microsoft.com/)
* [VS Code](https://code.visualstudio.com/)
* [thoughtbot/laptop](https://github.com/thoughtbot/laptop)
* [MDN Web Docs](https://developer.mozilla.org/en-US/)
* [GitHub Codespaces](https://github.com/features/codespaces/)
